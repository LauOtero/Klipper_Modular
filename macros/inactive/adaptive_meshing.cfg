# # # Klipper Adaptive Meshing # # #

# Heads up! If you have any other BED_MESH_CALIBRATE macros defined elsewhere in your config, you will need to comment out / remove them for this to work. (Klicky/Euclid Probe)
# You will also need to be sure that [exclude_object] is defined in printer.cfg, and your slicer is labeling objects.
# This macro will parse information from objects in your gcode to define a min and max mesh area to probe, creating an adaptive mesh!
# This macro will not increase probe_count values in your [bed_mesh] config. If you want richer meshes, be sure to increase probe_count. We recommend at least 5,5.

# ¡Aviso! Si tiene otras macros BED_MESH_CALIBRATE definidas en otra parte de su configuración, deberá comentarlas/eliminarlas para que esto funcione. (Sonda Klicky/Euclid)
# También deberá asegurarse de que [exclude_object] esté definido en printer.cfg, y que su segmentación esté etiquetando objetos.
# ¡Esta macro analizará la información de los objetos en su gcode para definir un área de malla mínima y máxima para sondear, creando una malla adaptativa!
# Esta macro no aumentará los valores probe_count en su configuración [bed_mesh]. Si desea mallas más ricas, asegúrese de aumentar probe_count. Recomendamos al menos 5,5.

[gcode_macro BED_MESH_CALIBRATE]
rename_existing: _BED_MESH_CALIBRATE

### Esta sección permite el control de los LED de estado que pueda tener su impresora.

variable_led_enable: False                  # Habilita/deshabilita el uso de LED de estado en esta macro.
variable_led_status_macro: 'status_meshing' # Si tiene LED de estado en su impresora (StealthBurner), puede usar la macro que cambia su estado aquí.

### Esta sección configura guarda las coordenadas del sondeo, con el area enviada por el laminador.
variable_print_min: 0                    # coordenadas minimas del area de sondeo.   
variable_print_max: 0                    # coordenadas maximas del area de sondeo.  

### Esta sección configura el fuzzing de puntos de malla, que permite variar ligeramente los puntos de sondeo si se imprimen múltiplos del mismo archivo de código G.

variable_fuzz_enable: False             # Habilita/deshabilita el uso de fuzzing de puntos de malla para aleatorizar ligeramente los puntos de sondeo para distribuir el
                                        # desgaste en una superficie de construcción; el valor predeterminado es Falso.
variable_fuzz_min: 0                    # Si está habilitado, la cantidad mínima en mm que se puede aleatorizar un punto de sonda, el valor predeterminado es 0.
variable_fuzz_max: 4                    # Si está habilitado, la cantidad máxima en mm que se puede aleatorizar un punto de sonda, el valor predeterminado es 4.

### Esta sección es para configurar un margen de malla, que permite que la malla probada se expanda hacia afuera del área de impresión.

variable_margin_enable: False           # Habilita/deshabilita la adición de un margen al área de malla para rellenar una malla para necesidades específicas; el valor predeterminado es Falso.
variable_margin_size: 5                 # Tamaño en milímetros para expandir la malla hacia afuera desde el área de impresión en todas las direcciones.

### Esta sección es para aquellos que utilizan una sonda acoplable que se almacena fuera del área de impresión. ###

variable_probe_dock_enable: False       # Habilita/deshabilita el uso de una sonda acoplable que se almacena fuera del área de impresión; el valor predeterminado es Falso.
variable_attach_macro: 'Attach_Probe'   # Aquí es donde define la macro que CONECTA la sonda al cabezal de impresión. P.ej. 'Attach_Probe'
variable_detach_macro: 'Dock_Probe'     # Aquí es donde define la macro que SEPARA la sonda del cabezal de impresión. P.ej. 'Dock_Probe'

### Esta sección es para aquellos que usan el Administrador de actualizaciones de Moonraker para KAMP o desean una macro más detallada. ###

variable_display_parameters: True       # Mostrar parámetros de macro en la consola, útil para depurar la llamada SETUP_KAMP_MESHING, o más información.

gcode:

    {% if display_parameters %}
      { action_respond_info("led_enable  : %d" % (led_enable))  }
      { action_respond_info("status_macro: \'%s\'" % (status_macro))  }
      { action_respond_info("fuzz_enable : %d" % (fuzz_enable))  }
      { action_respond_info("fuzz_min    : %f" % (fuzz_min))  }
      { action_respond_info("fuzz_max    : %f" % (fuzz_max))  }
      { action_respond_info("probe_dock_enable: %d" % (probe_dock_enable))  }
      { action_respond_info("attach_macro: \'%s\'" % (attach_macro))  }
      { action_respond_info("detach_macro: \'%s\'" % (detach_macro))  }
    {% endif %}
    
    {% set area_slicer_enabled = ',' in print_min and ',' in print_max %}

    {% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}
    {% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}
    {% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}
    {% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}
    {% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}
    {% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}

    {% if area_slicer_enabled %}
        {% set x_min = print_min.split(",")[0]|float %} 
        {% set y_min = print_min.split(",")[1]|float %}
        {% set x_max = print_max.split(",")[0]|float %} 
        {% set y_max = print_max.split(",")[1]|float %}
    {% else %}
        {% set all_points = printer.exclude_object.objects | map(attribute='polygon') | sum(start=[]) %}
        {% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}
        {% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}
        {% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}
        {% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}

        { action_respond_info("{} object points, clamping to bed mesh [{!r} {!r}]".format(
            all_points | count,
            bed_mesh_min,
            bed_mesh_max,
        )) }
    {% endif %}

    {% if not margin_enable %}
        {% set margin_size = 0 %}
    {% endif %}
    
    {% if fuzz_enable %}
        {% set fuzz_range = range((fuzz_min * 100) | int, (fuzz_max * 100) | int + 1) %}
        {% set x_min = (bed_mesh_min[0] + fuzz_max - margin_size, x_min) | max - (fuzz_range | random / 100.0) %}
        {% set y_min = (bed_mesh_min[1] + fuzz_max - margin_size, y_min) | max - (fuzz_range | random / 100.0) %}
        {% set x_max = (bed_mesh_max[0] - fuzz_max + margin_size, x_max) | min + (fuzz_range | random / 100.0) %}
        {% set y_max = (bed_mesh_max[1] - fuzz_max + margin_size, y_max) | min + (fuzz_range | random / 100.0) %}
    {% else %}
        {% set x_min = [ bed_mesh_min[0], x_min - margin_size ] | max %}
        {% set y_min = [ bed_mesh_min[1], y_min - margin_size ] | max %}
        {% set x_max = [ bed_mesh_max[0], x_max + margin_size ] | min %}
        {% set y_max = [ bed_mesh_max[1], y_max + margin_size ] | min %}
    {% endif %}

    { action_respond_info("Object bounds, clamped to the bed_mesh: {!r}, {!r}".format(
        (x_min, y_min),
        (x_max, y_max),
    )) }

    {% set points_x = (((x_max - x_min) / max_probe_point_distance_x) | round(method='ceil') | int) + 1 %}
    {% set points_y = (((y_max - y_min) / max_probe_point_distance_y) | round(method='ceil') | int) + 1 %}

    {% if (([points_x, points_y]|max) > 6) %}
        {% set algorithm = "bicubic" %}
        {% set min_points = 4 %}
    {% else %}
        {% set algorithm = "lagrange" %}
        {% set min_points = 3 %}
    {% endif %}
    { action_respond_info( "Algorithm: {}".format(algorithm)) }

    {% set points_x = [points_x, min_points]|max  %}
    {% set points_y = [points_y, min_points]|max  %}
    { action_respond_info( "Points: x: {}, y: {}".format(points_x, points_y) ) }

    {% if printer.configfile.settings.bed_mesh.relative_reference_index is defined %}
        {% set ref_index = (points_x * points_y / 2) | int %}
        { action_respond_info( "Reference index: {}".format(ref_index) ) }
    {% else %}
        {% set ref_index = -1 %}
    {% endif %}

    {% if probe_dock_enable %}
        {attach_macro}              # Recoge la sonda, si está almacenada en algún lugar fuera del área de impresión
    {% endif %}

    {% if led_enable %}
        {led_status_macro}          # Establece el estado del LED
    {% endif %}

    _BED_MESH_CALIBRATE mesh_min={x_min},{y_min} mesh_max={x_max},{y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y} RELATIVE_REFERENCE_INDEX={ref_index}

    {% if probe_dock_enable %}
        {detach_macro}              # Libera la sonda, si está almacenada en algún lugar fuera del área de impresión
    {% endif %}

[gcode_macro SETUP_BED_MESH_CALIBRATE]
gcode:
  SET_GCODE_VARIABLE MACRO=BED_MESH_CALIBRATE VARIABLE=display_parameters   VALUE={params.DISPLAY_PARAMETERS|default(True)|int}
  SET_GCODE_VARIABLE MACRO=BED_MESH_CALIBRATE VARIABLE=led_enable   VALUE={params.LED_ENABLE|default(False)|int}
  SET_GCODE_VARIABLE MACRO=BED_MESH_CALIBRATE VARIABLE=status_macro VALUE='"{params.STATUS_MACRO|default('status_meshing')|string}"'

  SET_GCODE_VARIABLE MACRO=BED_MESH_CALIBRATE VARIABLE=print_min    VALUE={params.PRINT_MIN|default(0)|float}
  SET_GCODE_VARIABLE MACRO=BED_MESH_CALIBRATE VARIABLE=print_max    VALUE={params.PRINT_MAX|default(0)|float}

  SET_GCODE_VARIABLE MACRO=BED_MESH_CALIBRATE VARIABLE=fuzz_enable VALUE={params.FUZZ_ENABLE|default(False)|int}
  SET_GCODE_VARIABLE MACRO=BED_MESH_CALIBRATE VARIABLE=fuzz_min    VALUE={params.FUZZ_MIN|default(0)|float}
  SET_GCODE_VARIABLE MACRO=BED_MESH_CALIBRATE VARIABLE=fuzz_max    VALUE={params.FUZZ_MAX|default(4)|float}

  SET_GCODE_VARIABLE MACRO=BED_MESH_CALIBRATE VARIABLE=probe_dock_enable  VALUE={params.PROBE_DOCK_ENABLE|default(False)|int}
  SET_GCODE_VARIABLE MACRO=BED_MESH_CALIBRATE VARIABLE=attach_macro VALUE='"{params.ATTACH_MACRO|default('Attach_Probe')|string}"'
  SET_GCODE_VARIABLE MACRO=BED_MESH_CALIBRATE VARIABLE=detach_macro VALUE='"{params.DETACH_MACRO|default('Dock_Probe')|string}"'